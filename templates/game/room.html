{% extends 'base.html' %}

{% block title %}Sala {{ game.code }} - VATGames{% endblock %}

{% block extra_css %}
<style>
    .room-container {
        display: grid;
        grid-template-columns: minmax(280px, 1fr) minmax(420px, 2fr);
        gap: 32px;
        align-items: start;
    }

    @media (max-width: 960px) {
        .room-container {
            grid-template-columns: 1fr;
            gap: 24px;
        }
    }

    .room-panel {
        display: flex;
        flex-direction: column;
        gap: 24px;
    }

    .game-status {
        padding: 20px;
        border-radius: 20px;
        background: rgba(12, 16, 24, 0.85);
        border: 1px solid rgba(77, 212, 255, 0.12);
        display: grid;
        gap: 10px;
    }

    .game-status span {
        font-weight: 600;
        color: var(--text-100);
    }

    .players-list {
        margin-top: 12px;
    }

    .player-item.current-turn {
        cursor: pointer;
        transition: transform 0.15s ease, border-color 0.15s ease;
    }

    .player-item.current-turn:focus-visible {
        outline: 2px solid var(--accent-500);
        outline-offset: 2px;
    }

    .player-item.current-turn.pinged {
        border-color: rgba(77, 212, 255, 0.8);
        box-shadow: 0 0 0 2px rgba(77, 212, 255, 0.25);
        transform: translateX(2px);
    }

    .player-item.voted {
        border-color: rgba(45, 211, 111, 0.6);
        background: linear-gradient(120deg, rgba(45, 211, 111, 0.15), rgba(26, 32, 44, 0.85));
    }

    .room-action {
        margin-top: 16px;
    }

    .hint-input {
        margin-top: 20px;
    }

    .hint-input label {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.85rem;
        color: var(--text-300);
    }

    .hint-input .btn {
        margin-top: 12px;
    }

    #vote-buttons {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 12px;
    }

    #results-section {
        margin-top: 32px;
    }

    .timer-card {
        margin: 20px 0;
        padding: 15px 18px;
        border-radius: 18px;
        background: rgba(244, 180, 0, 0.14);
        border: 1px solid rgba(244, 180, 0, 0.45);
        text-align: center;
        transition: border-color 0.2s ease, background 0.2s ease;
    }

    .timer-card.is-warning {
        background: rgba(244, 180, 0, 0.25);
        border-color: rgba(244, 180, 0, 0.65);
    }

    .timer-card.is-danger {
        background: rgba(255, 77, 109, 0.18);
        border-color: rgba(255, 77, 109, 0.65);
    }

    #game-actions {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 12px;
    }

    .danger-text {
        color: var(--danger-500);
        font-weight: 600;
    }

    .btn-kick {
        background: rgba(255, 77, 109, 0.15);
        border: 1px solid rgba(255, 77, 109, 0.4);
        color: var(--danger-500);
        border-radius: 8px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.2s ease;
        margin-left: auto;
    }

    .btn-kick:hover {
        background: rgba(255, 77, 109, 0.3);
        border-color: rgba(255, 77, 109, 0.6);
        transform: scale(1.05);
    }

    .player-item {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .player-item > span:first-child {
        flex: 1;
    }

    #notification-banner {
        margin: 15px 0;
        padding: 12px 16px;
        background: rgba(77, 212, 255, 0.1);
        border: 1px solid rgba(77, 212, 255, 0.3);
        border-radius: 12px;
        display: none;
        align-items: center;
        gap: 12px;
    }

    #notification-banner.show {
        display: flex;
    }

    #notification-banner button {
        padding: 6px 14px;
        border-radius: 8px;
        background: rgba(77, 212, 255, 0.2);
        border: 1px solid rgba(77, 212, 255, 0.4);
        color: var(--accent-500);
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
    }

    #notification-banner button:hover {
        background: rgba(77, 212, 255, 0.3);
        border-color: rgba(77, 212, 255, 0.6);
    }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h1>Sala: {{ game.code }}{% if is_spectator %}<span class="spectator-badge">üëÅÔ∏è ESPECTADOR</span>{% endif %}</h1>

    {% if not player and not is_spectator %}
    <div class="error">
        Voc√™ n√£o est√° nesta sala. Por favor, entre com seu nome.
    </div>
    {% else %}

    <div id="notification-banner">
        <span>üîî Ative as notifica√ß√µes para ser alertado quando for sua vez!</span>
        <button id="enable-notifications">Ativar Notifica√ß√µes</button>
    </div>

    {% if player %}
    <button id="streamer-toggle" class="streamer-toggle" title="Modo Streamer - Oculta palavra e fun√ß√£o">
        üì∫ Modo Streamer
    </button>
    {% endif %}

    <div class="room-container">
        <div class="room-panel">
            <div class="game-status">
                <h3>Status: <span id="game-status">{{ game.get_status_display }}</span></h3>
                <p>Rodada: <span id="current-round">{{ game.current_round }}</span></p>
                <p>Jogadores: <span id="player-count">{{ game.players.count }}</span>/{{ game.max_players }}</p>
            </div>

            <div>
                <h3>Jogadores:</h3>
                <ul class="players-list" id="players-list">
                    {% for p in players %}
                    <li class="player-item{% if p.is_creator %} creator{% endif %}{% if p.is_eliminated %} eliminated{% endif %}" data-player-id="{{ p.id }}">
                        {{ p.name }}
                        {% if p.is_eliminated %}<span class="danger-text">‚ùå</span>{% endif %}
                    </li>
                    {% endfor %}
                </ul>
            </div>

            <div id="game-controls"></div>
        </div>

        <div class="room-panel">
            <div id="word-display" class="word-display" style="display: none;">
                <div>Sua palavra: <span id="my-word"></span></div>
            </div>

            <div id="role-display" class="role-display" style="display: none;">
                Seu papel: <span id="my-role"></span>
            </div>

            <div id="current-turn-display" class="current-turn-display" style="display: none;">
                <div>√â a vez de: <span id="current-turn-player"></span></div>
            </div>

            <div id="hints-section">
                <h3>Dicas:</h3>
                <div id="hints-list" class="hints-list"></div>

                <div id="hint-input-section" style="display: none;">
                    <div class="hint-input">
                        <label>Digite uma palavra (dica):</label>
                        <input type="text" id="hint-word" placeholder="Digite uma palavra" maxlength="50">
                        <button id="submit-hint" class="btn btn-block">Enviar Dica</button>
                    </div>
                </div>
            </div>

            <div id="voting-section" class="voting-section" style="display: none;">
                <h3>Vota√ß√£o:</h3>
                <p>Escolha quem voc√™ acha que √© o impostor:</p>
                <div id="vote-buttons"></div>
            </div>

            <div id="results-section" class="results-panel" style="display: none;">
                <h3>Resultado do Jogo:</h3>
                <div id="winner-message"></div>
                <div id="roles-reveal"></div>
                <div id="auto-delete-timer" class="timer-card" style="display: none;">
                    <strong>‚è∞ <span id="timer-text">A sala ser√° fechada automaticamente em 60 segundos...</span></strong>
                </div>
                <div id="game-actions"></div>
            </div>
        </div>
    </div>

    {% endif %}
</div>

<script>
const gameCode = '{{ game.code }}';
const playerName = '{{ player.name|default:"" }}';
const isSpectator = {% if is_spectator %}true{% else %}false{% endif %};
const POLL_INTERVAL_MS = 10000;
const stateUrl = `/api/game/${gameCode}/state/${isSpectator ? '?spectator=1' : ''}`;
const apiBaseUrl = `/api/game/${gameCode}`;
let pollTimer = null;
let isFetchingState = false;
let streamerMode = false;
let lastHintCount = 0;
let lastCurrentPlayer = null;
let lastGameStatus = null;
let notificationsEnabled = false;

function playSound(frequency, duration, type = 'sine') {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
        console.log('Audio n√£o dispon√≠vel:', e);
    }
}

function playHintSound() {
    playSound(800, 0.1, 'sine');
    setTimeout(() => playSound(1000, 0.1, 'sine'), 50);
}

function playYourTurnSound() {
    playSound(600, 0.15, 'sine');
    setTimeout(() => playSound(800, 0.15, 'sine'), 100);
    setTimeout(() => playSound(1000, 0.2, 'sine'), 200);
}

function handlePlayerPing(element) {
    if (!element) {
        return;
    }
    playYourTurnSound();
    element.classList.add('pinged');
    setTimeout(() => element.classList.remove('pinged'), 400);
}

function attachPlayerPingHandlers() {
    const playersList = document.getElementById('players-list');
    if (!playersList) {
        return;
    }
    playersList.querySelectorAll('.player-item.current-turn').forEach(item => {
        item.addEventListener('click', () => handlePlayerPing(item));
        item.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                handlePlayerPing(item);
            }
        });
    });
}

function requestNotificationPermission() {
    if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
            notificationsEnabled = (permission === 'granted');
            updateNotificationBanner();
        });
    } else if ('Notification' in window && Notification.permission === 'granted') {
        notificationsEnabled = true;
        updateNotificationBanner();
    }
}

function updateNotificationBanner() {
    const banner = document.getElementById('notification-banner');
    if (!banner) return;
    
    if ('Notification' in window && Notification.permission === 'default') {
        banner.classList.add('show');
    } else {
        banner.classList.remove('show');
    }
}

function showNotification(title, body, requireFocus = true) {
    // Only show notification if tab is not focused or requireFocus is false
    if (!requireFocus || document.hidden) {
        if (notificationsEnabled && 'Notification' in window && Notification.permission === 'granted') {
            new Notification(title, {
                body: body,
                icon: '/static/favicon.ico',
                badge: '/static/favicon.ico',
                tag: 'vatimposter-game'
            });
        }
    }
}

function handleRoomClosed(data) {
    if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
    }
    alert(data.message || 'A sala foi fechada.');
    const redirect = data.redirect || '/';
    window.location.href = redirect;
}

async function fetchGameState(showError = false) {
    if (isFetchingState) {
        return;
    }
    isFetchingState = true;
    try {
        const response = await fetch(stateUrl, {
            cache: 'no-store',
            credentials: 'same-origin'
        });
        if (!response.ok) {
            throw new Error('Falha ao buscar estado do jogo');
        }
        const data = await response.json();
        if (data.room_closed) {
            handleRoomClosed(data);
            return;
        }
        updateGameState(data);
    } catch (error) {
        console.error('Erro ao atualizar estado do jogo:', error);
        if (showError) {
            alert('N√£o foi poss√≠vel atualizar o estado do jogo. Verifique sua conex√£o.');
        }
    } finally {
        isFetchingState = false;
    }
}

async function postAction(action, payload) {
    try {
        const response = await fetch(`${apiBaseUrl}/${action}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify(payload)
        });
        const data = await response.json();
        if (!response.ok || data.error) {
            throw new Error(data.error || 'Falha ao processar a√ß√£o');
        }
        if (data.room_closed) {
            handleRoomClosed(data);
            return data;
        }
        await fetchGameState();
        return data;
    } catch (error) {
        alert(error.message || 'Erro ao executar a√ß√£o.');
        throw error;
    }
}

function startPolling() {
    fetchGameState(true);
    if (pollTimer) {
        clearInterval(pollTimer);
    }
    pollTimer = setInterval(fetchGameState, POLL_INTERVAL_MS);
}

function updateGameState(state) {
    const game = state.game || {};
    const players = state.players || [];
    const hints = state.hints || [];
    const votes = state.votes || [];
    const autoDeleteSeconds = state.auto_delete_seconds;

    document.getElementById('game-status').textContent = getStatusText(game.status);
    document.getElementById('current-round').textContent = game.current_round;
    document.getElementById('player-count').textContent = players.length;

    // Controlar bot√µes de iniciar e reiniciar dinamicamente
    const currentPlayer = players.find(p => p.name === playerName);
    const gameControls = document.getElementById('game-controls');
    
    if (gameControls) {
        if (currentPlayer && currentPlayer.is_creator && !isSpectator) {
            if (game.status === 'waiting') {
                gameControls.innerHTML = `
                    <button id="start-btn" class="btn btn-block room-action">
                        Iniciar Jogo
                    </button>
                `;
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        postAction('start', { player_name: playerName }).catch(() => {});
                    });
                }
            } else if (game.status !== 'finished') {
                gameControls.innerHTML = `
                    <button id="restart-game-btn" class="btn btn-secondary btn-block room-action">
                        üîÑ Reiniciar Jogo
                    </button>
                `;
                const restartBtn = document.getElementById('restart-game-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        if (confirm('Deseja reiniciar o jogo? Todos receber√£o novas palavras e o jogo come√ßar√° do zero.')) {
                            postAction('restart', { player_name: playerName }).catch(() => {});
                        }
                    });
                }
            } else {
                gameControls.innerHTML = '';
            }
        } else {
            gameControls.innerHTML = '';
        }
    }

    const playersList = document.getElementById('players-list');
    const currentTurnPlayer = game.status === 'hints' ? game.current_player : null;
    const canKick = currentPlayer && currentPlayer.is_creator && !isSpectator && (game.status === 'waiting' || game.status === 'configuring');
    
    playersList.innerHTML = players.map(p => {
        let classes = 'player-item';
        if (p.is_creator) classes += ' creator';
        if (p.is_eliminated) classes += ' eliminated';
        if (currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated) {
            classes += ' current-turn';
        }
        // Destacar quem j√° votou
        if (game.status === 'voting' && votes.some(v => v.voter_name === p.name)) {
            classes += ' voted';
        }
        const eliminationIcon = p.is_eliminated ? ' <span class="danger-text">‚ùå</span>' : '';
        const whitemanBadge = p.role === 'whiteman' && p.is_eliminated ? ' <span class="whiteman-badge">‚ö™ WhiteMan</span>' : '';
        const isCurrentTurn = currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated;
        const interactiveAttrs = isCurrentTurn 
            ? `role="button" tabindex="0" aria-label="Alertar turno de ${p.name}" title="Tocar alerta para ${p.name}"`
            : '';
        
        // Bot√£o de kick apenas para o criador, na sala de espera, e n√£o para si mesmo
        const kickButton = canKick && p.name !== playerName 
            ? `<button class="btn-kick" data-player-name="${p.name}" title="Remover jogador">‚úï</button>`
            : '';
        
        return `<li class="${classes}" data-player-id="${p.id}" ${interactiveAttrs}>
            <span>${p.name}${eliminationIcon}${whitemanBadge}</span>
            ${kickButton}
        </li>`;
    }).join('');
    
    // Adicionar event listeners para os bot√µes de kick
    if (canKick) {
        playersList.querySelectorAll('.btn-kick').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const targetName = btn.dataset.playerName;
                if (confirm(`Remover ${targetName} da sala?`)) {
                    postAction('kick', {
                        player_name: playerName,
                        target_player_name: targetName
                    }).catch(() => {});
                }
            });
        });
    }

    attachPlayerPingHandlers();

    if (game.status !== 'waiting' && game.status !== 'configuring' && !isSpectator) {
        const player = players.find(p => p.name === playerName);
        if (player && player.role) {
            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');

            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                const displayRole = player.role === 'whiteman' ? 'citizen' : player.role;
                roleDisplay.innerHTML = `Seu papel: <span id="my-role">${getRoleText(displayRole)}</span>`;
                roleDisplay.style.display = 'block';

                if (player.role === 'whiteman') {
                    if (player.word) {
                        wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                    } else {
                        wordDisplay.style.display = 'none';
                    }
                } else if (player.role === 'impostor') {
                    wordDisplay.innerHTML = `<div class="danger-text">‚ö†Ô∏è VOC√ä √â O IMPOSTOR!</div><div>Sua palavra (diferente dos cidad√£os): <span id="my-word" class="danger-text">${player.word || 'N/A'}</span></div>`;
                } else if (player.word) {
                    wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                } else {
                    wordDisplay.style.display = 'none';
                }

                wordDisplay.style.display = 'block';
            }
        }
    }

    const hintsList = document.getElementById('hints-list');
    hintsList.innerHTML = hints.map(h => {
        return `<div class="hint-item">
            <strong>${h.player_name}</strong> (Rodada ${h.round_number}): ${h.word}
        </div>`;
    }).join('');

    if (hints.length > lastHintCount && game.status === 'hints') {
        playHintSound();
        
        // Show notification for new hints
        if (hints.length > 0 && lastHintCount > 0) {
            const newHint = hints[hints.length - 1];
            showNotification(
                'üí° Nova Dica!',
                `${newHint.player_name}: ${newHint.word}`
            );
        }
        
        // Scroll para a √∫ltima dica
        setTimeout(() => {
            hintsList.scrollTop = hintsList.scrollHeight;
        }, 50);
    }
    lastHintCount = hints.length;

    const currentTurnDisplay = document.getElementById('current-turn-display');
    const currentTurnPlayerSpan = document.getElementById('current-turn-player');
    if (game.status === 'hints' && game.current_player) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            currentTurnDisplay.style.display = 'block';
            currentTurnPlayerSpan.textContent = game.current_player;

            if (game.current_player === playerName && game.current_player !== lastCurrentPlayer) {
                playYourTurnSound();
                showNotification(
                    'üéÆ Sua Vez!',
                    '√â sua vez de dar uma dica!',
                    false  // Always show, even if tab is focused
                );
            }
        } else {
            currentTurnDisplay.style.display = 'none';
        }
    } else {
        currentTurnDisplay.style.display = 'none';
    }
    lastCurrentPlayer = game.current_player;

    // Notify when voting starts
    if (game.status === 'voting' && lastGameStatus === 'hints' && !isSpectator) {
        showNotification(
            'üó≥Ô∏è Vota√ß√£o Iniciada!',
            '√â hora de votar no impostor!',
            false
        );
    }

    // Notify when game finishes
    if (game.status === 'finished' && lastGameStatus !== 'finished') {
        const impostors = players.filter(p => p.role === 'impostor');
        const activeImpostors = impostors.filter(p => !p.is_eliminated);
        const winner = activeImpostors.length === 0 ? 'Cidad√£os' : 'Impostores';
        showNotification(
            'üèÜ Jogo Finalizado!',
            `${winner} venceram!`,
            false
        );
    }

    lastGameStatus = game.status;

    const hintInputSection = document.getElementById('hint-input-section');
    if (game.status === 'hints' && game.current_player === playerName && !isSpectator) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            hintInputSection.style.display = 'block';
        }
    } else {
        hintInputSection.style.display = 'none';
    }

    if (isSpectator) {
        document.getElementById('word-display').style.display = 'none';
        document.getElementById('role-display').style.display = 'none';
        document.getElementById('hint-input-section').style.display = 'none';
        document.getElementById('voting-section').style.display = 'none';
    }

    const votingSection = document.getElementById('voting-section');
    if (!isSpectator && game.status === 'voting') {
        votingSection.style.display = 'block';
        const activePlayers = players.filter(p => !p.is_eliminated && p.name !== playerName);
        const voteButtons = document.getElementById('vote-buttons');
        voteButtons.innerHTML = activePlayers.map(p => {
            const hasVoted = votes.some(v => v.voter_name === playerName);
            return `<button class="vote-button ${hasVoted ? 'voted' : ''}" 
                    data-target="${p.name}" 
                    ${hasVoted ? 'disabled' : ''}>
                ${p.name}
            </button>`;
        }).join('');

        voteButtons.querySelectorAll('.vote-button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!btn.disabled) {
                    postAction('vote', {
                        player_name: playerName,
                        target_name: btn.dataset.target
                    }).catch(() => {});
                }
            });
        });
    } else {
        votingSection.style.display = 'none';
    }

    const resultsSection = document.getElementById('results-section');
    if (game.status === 'finished') {
        resultsSection.style.display = 'block';

        const impostors = players.filter(p => p.role === 'impostor');
        const activeImpostors = impostors.filter(p => !p.is_eliminated);

        let winnerMessage = '';
        if (activeImpostors.length === 0) {
            winnerMessage = 'üèÜ Cidad√£os ganharam!';
        } else {
            winnerMessage = 'üèÜ Impostores ganharam!';
        }

        document.getElementById('winner-message').innerHTML = `<h2>${winnerMessage}</h2>`;

        const rolesReveal = document.getElementById('roles-reveal');
        rolesReveal.innerHTML = '<h3>Pap√©is revelados:</h3>' + 
            players.map(p => {
                const wordText = p.word ? ` (${p.word})` : '';
                const whitemanAlert = p.role === 'whiteman' && p.is_eliminated ? ' <span class="whiteman-badge">‚ö†Ô∏è Era WhiteMan!</span>' : '';
                return `<div class="player-item">
                    ${p.name}: ${getRoleText(p.role)}${wordText}${whitemanAlert}
                </div>`;
            }).join('');

        renderAutoDeleteTimer(autoDeleteSeconds);

        const currentPlayer = players.find(p => p.name === playerName);
        const gameActions = document.getElementById('game-actions');
        if (currentPlayer && currentPlayer.is_creator) {
            gameActions.innerHTML = `
                <button id="restart-btn" class="btn">
                    üîÑ Reiniciar Jogo
                </button>
                <button id="close-room-btn" class="btn btn-danger">
                    üóëÔ∏è Fechar Sala
                </button>
            `;

            const restartBtn = document.getElementById('restart-btn');
            const closeBtn = document.getElementById('close-room-btn');

            if (restartBtn) {
                restartBtn.onclick = () => {
                    if (confirm('Deseja reiniciar o jogo com os mesmos jogadores?')) {
                        postAction('restart', {
                            player_name: playerName
                        }).catch(() => {});
                    }
                };
            }

            if (closeBtn) {
                closeBtn.onclick = () => {
                    if (confirm('Tem certeza que deseja fechar a sala? Isso apagar√° todos os dados do jogo!')) {
                        postAction('close', {
                            player_name: playerName
                        }).catch(() => {});
                    }
                };
            }
        } else {
            gameActions.innerHTML = '<p>Aguardando o criador da sala reiniciar ou fechar...</p>';
        }
    } else {
        resultsSection.style.display = 'none';
        document.getElementById('winner-message').innerHTML = '';
        document.getElementById('roles-reveal').innerHTML = '';
        renderAutoDeleteTimer(null);
    }
}

function getStatusText(status) {
    const statusMap = {
        'waiting': 'Aguardando Jogadores',
        'configuring': 'Configurando',
        'hints': 'Rodada de Dicas',
        'voting': 'Vota√ß√£o',
        'finished': 'Finalizado'
    };
    return statusMap[status] || status;
}

function getRoleText(role) {
    const roleMap = {
        'citizen': 'Cidad√£o',
        'impostor': 'Impostor',
        'whiteman': 'WhiteMan'
    };
    return roleMap[role] || role;
}

function renderAutoDeleteTimer(remainingSeconds) {
    const timerDiv = document.getElementById('auto-delete-timer');
    const timerText = document.getElementById('timer-text');
    if (!timerDiv || !timerText) {
        return;
    }

    timerDiv.classList.remove('is-warning', 'is-danger');

    if (remainingSeconds === null || remainingSeconds === undefined) {
        timerDiv.style.display = 'none';
        timerText.textContent = '';
        return;
    }

    timerDiv.style.display = 'block';

    if (remainingSeconds <= 10) {
        timerDiv.classList.add('is-danger');
    } else if (remainingSeconds <= 20) {
        timerDiv.classList.add('is-warning');
    }

    if (remainingSeconds <= 0) {
        timerText.textContent = 'A sala ser√° fechada a qualquer momento...';
    } else {
        const label = remainingSeconds === 1 ? '1 segundo' : `${remainingSeconds} segundos`;
        timerText.textContent = `A sala ser√° fechada automaticamente em ${label}...`;
    }
}

if (playerName && !isSpectator) {
    const streamerToggle = document.getElementById('streamer-toggle');
    if (streamerToggle) {
        streamerToggle.addEventListener('click', () => {
            streamerMode = !streamerMode;
            document.body.classList.toggle('streamer-mode', streamerMode);
            streamerToggle.classList.toggle('active', streamerMode);
            streamerToggle.textContent = streamerMode ? 'üîì Modo Normal' : 'üì∫ Modo Streamer';

            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');
            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                fetchGameState(true);
            }
        });
    }
}

if (playerName && !isSpectator) {
    const submitHintBtn = document.getElementById('submit-hint');
    const hintInput = document.getElementById('hint-word');

    if (submitHintBtn && hintInput) {
        submitHintBtn.addEventListener('click', async () => {
            const word = hintInput.value.trim();
            if (!word) {
                return;
            }
            submitHintBtn.disabled = true;
            try {
                await postAction('hint', {
                    player_name: playerName,
                    word: word
                });
                hintInput.value = '';
            } catch (error) {
                console.error('Erro ao enviar dica:', error);
            } finally {
                submitHintBtn.disabled = false;
            }
        });

        hintInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitHintBtn.click();
            }
        });
    }
}

if (playerName || isSpectator) {
    // Request notification permission
    requestNotificationPermission();
    updateNotificationBanner();
    
    const enableNotifBtn = document.getElementById('enable-notifications');
    if (enableNotifBtn) {
        enableNotifBtn.addEventListener('click', () => {
            requestNotificationPermission();
        });
    }
    
    startPolling();
    window.addEventListener('beforeunload', () => {
        if (pollTimer) {
            clearInterval(pollTimer);
        }
    });
}
</script>
{% endblock %}


