{% extends 'base.html' %}

{% block title %}Sala {{ game.code }} - VATGames{% endblock %}

{% block extra_css %}
<style>
    .room-container {
        display: grid;
        grid-template-columns: minmax(280px, 1fr) minmax(420px, 2fr);
        gap: 32px;
        align-items: start;
    }

    @media (max-width: 960px) {
        .room-container {
            grid-template-columns: 1fr;
            gap: 24px;
        }
    }

    .room-panel {
        display: flex;
        flex-direction: column;
        gap: 24px;
    }

    .game-status {
        padding: 20px;
        border-radius: 20px;
        background: rgba(12, 16, 24, 0.85);
        border: 1px solid rgba(77, 212, 255, 0.12);
        display: grid;
        gap: 10px;
    }

    .game-status span {
        font-weight: 600;
        color: var(--text-100);
    }

    .players-list {
        margin-top: 12px;
    }

    .player-item.current-turn {
        cursor: pointer;
        transition: transform 0.15s ease, border-color 0.15s ease;
    }

    .player-item.current-turn:focus-visible {
        outline: 2px solid var(--accent-500);
        outline-offset: 2px;
    }

    .player-item.current-turn.pinged {
        border-color: rgba(77, 212, 255, 0.8);
        box-shadow: 0 0 0 2px rgba(77, 212, 255, 0.25);
        transform: translateX(2px);
    }

    .player-item.voted {
        border-color: rgba(45, 211, 111, 0.6);
        background: linear-gradient(120deg, rgba(45, 211, 111, 0.15), rgba(26, 32, 44, 0.85));
    }

    .room-action {
        margin-top: 16px;
    }

    .hint-input {
        margin-top: 20px;
    }

    .hint-input label {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.85rem;
        color: var(--text-300);
    }

    .hint-input .btn {
        margin-top: 12px;
    }

    #vote-buttons {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 12px;
    }

    #results-section {
        margin-top: 32px;
    }

    .timer-card {
        margin: 20px 0;
        padding: 15px 18px;
        border-radius: 18px;
        background: rgba(244, 180, 0, 0.14);
        border: 1px solid rgba(244, 180, 0, 0.45);
        text-align: center;
        transition: border-color 0.2s ease, background 0.2s ease;
    }

    .timer-card.is-warning {
        background: rgba(244, 180, 0, 0.25);
        border-color: rgba(244, 180, 0, 0.65);
    }

    .timer-card.is-danger {
        background: rgba(255, 77, 109, 0.18);
        border-color: rgba(255, 77, 109, 0.65);
    }

    #game-actions {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 12px;
    }

    .danger-text {
        color: var(--danger-500);
        font-weight: 600;
    }

    .btn-kick {
        background: rgba(255, 77, 109, 0.15);
        border: 1px solid rgba(255, 77, 109, 0.4);
        color: var(--danger-500);
        border-radius: 8px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.2s ease;
        margin-left: auto;
    }

    .btn-kick:hover {
        background: rgba(255, 77, 109, 0.3);
        border-color: rgba(255, 77, 109, 0.6);
        transform: scale(1.05);
    }

    .player-item {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid rgba(77, 212, 255, 0.08);
        background: rgba(10, 14, 22, 0.65);
        transition: border-color 0.15s ease, background 0.15s ease;
    }

    .palhaco-panel {
        margin-top: 16px;
        padding: 16px;
        border-radius: 16px;
        border: 1px solid rgba(244, 180, 0, 0.35);
        background: rgba(244, 180, 0, 0.08);
    }

    .palhaco-panel h3 {
        margin-top: 0;
        margin-bottom: 8px;
    }

    .palhaco-known-list {
        list-style: none;
        padding-left: 0;
        margin: 10px 0;
    }

    .palhaco-known-list li {
        padding: 6px 8px;
        border-radius: 10px;
        background: rgba(10, 14, 22, 0.55);
        margin-bottom: 6px;
        border: 1px solid rgba(244, 180, 0, 0.25);
    }

    .clown-badge {
        color: #f4b400;
        font-weight: 600;
        margin-left: 4px;
    }

    .whiteman-badge {
        color: #cbd5ff;
        font-weight: 600;
        margin-left: 4px;
    }

    .player-main-row {
        display: flex;
        align-items: center;
        gap: 12px;
        width: 100%;
    }

    .player-main-row > span:first-child {
        flex: 1;
    }

    .nudge-meter {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.8rem;
        color: var(--text-300);
    }

    .nudge-meter-track {
        flex: 1;
        height: 8px;
        border-radius: 999px;
        background: rgba(26, 43, 36, 0.8);
        overflow: hidden;
    }

    .nudge-meter-fill {
        height: 100%;
        border-radius: inherit;
        background: linear-gradient(120deg, rgba(45, 211, 111, 0.95), rgba(129, 255, 151, 0.95));
        transition: width 0.25s ease, background 0.25s ease, box-shadow 0.25s ease;
        box-shadow: 0 0 10px rgba(45, 211, 111, 0.4);
    }

    .nudge-meter-fill.is-warning {
        background: linear-gradient(120deg, rgba(244, 180, 0, 0.95), rgba(255, 210, 92, 0.95));
        box-shadow: 0 0 10px rgba(244, 180, 0, 0.45);
    }

    .nudge-meter-fill.is-danger {
        background: linear-gradient(120deg, rgba(255, 77, 109, 0.95), rgba(255, 126, 162, 0.95));
        box-shadow: 0 0 12px rgba(255, 77, 109, 0.6);
    }

    .nudge-meter-value {
        min-width: 52px;
        text-align: right;
        font-variant-numeric: tabular-nums;
        font-weight: 600;
        color: var(--text-200);
    }

    .nudge-meter-legend {
        margin-top: 6px;
        color: var(--text-400);
        font-size: 0.85rem;
    }

    .room-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
        margin-bottom: 20px;
    }

    .room-header h1 {
        margin: 0;
        flex: 1;
        min-width: 200px;
    }

    .share-link-btn {
        background: linear-gradient(135deg, rgba(77, 212, 255, 0.2), rgba(45, 211, 111, 0.2));
        border: 1px solid rgba(77, 212, 255, 0.4);
        color: var(--text-100);
        padding: 10px 20px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
    }

    .share-link-btn:hover {
        background: linear-gradient(135deg, rgba(77, 212, 255, 0.3), rgba(45, 211, 111, 0.3));
        border-color: rgba(77, 212, 255, 0.6);
        transform: translateY(-2px);
    }

    .share-link-btn.copied {
        background: linear-gradient(135deg, rgba(45, 211, 111, 0.3), rgba(45, 211, 111, 0.2));
        border-color: rgba(45, 211, 111, 0.6);
    }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <div class="room-header">
        <h1>Sala: {{ game.code }}{% if is_spectator %}<span class="spectator-badge">üëÅÔ∏è ESPECTADOR</span>{% endif %}</h1>
        <div style="display: flex; gap: 12px; align-items: center;">
            {% if player %}
            <button id="streamer-toggle" class="streamer-toggle" title="Modo Streamer - Oculta palavra e fun√ß√£o">
                üì∫ Modo Streamer
            </button>
            {% endif %}
            {% if not is_spectator %}
            <button id="share-link-btn" class="share-link-btn" title="Copiar link para compartilhar">
                üîó Compartilhar Link
            </button>
            {% endif %}
        </div>
    </div>

    {% if not player and not is_spectator %}
    <div class="error">
        Voc√™ n√£o est√° nesta sala. Por favor, entre com seu nome.
    </div>
    {% else %}

    <div class="room-container">
        <div class="room-panel">
            <div class="game-status">
                <h3>Status: <span id="game-status">{{ game.get_status_display }}</span></h3>
                <p>Rodada: <span id="current-round">{{ game.current_round }}</span></p>
                <p>Jogadores: <span id="player-count">{{ game.players.count }}</span>/<span id="player-count-max">{{ game.max_players }}</span></p>
            </div>

            <div>
                <h3>Jogadores:</h3>
                <p class="nudge-meter-legend">üíö HP come√ßa em 100. Cada cutucada reduz ‚Äî se zerar durante sua vez, voc√™ perde o turno.</p>
                <ul class="players-list" id="players-list">
                    {% for p in players %}
                    <li class="player-item{% if p.is_creator %} creator{% endif %}{% if p.is_eliminated %} eliminated{% endif %}" data-player-id="{{ p.id }}">
                        {{ p.name }}
                        {% if p.is_eliminated %}<span class="danger-text">‚ùå</span>{% endif %}
                    </li>
                    {% endfor %}
                </ul>
            </div>

            <div id="game-controls"></div>
        </div>

        <div class="room-panel">
            <div id="word-display" class="word-display" style="display: none;">
                <div>Sua palavra: <span id="my-word"></span></div>
            </div>

            <div id="role-display" class="role-display" style="display: none;">
                Seu papel: <span id="my-role"></span>
            </div>

            <div id="current-turn-display" class="current-turn-display" style="display: none;">
                <div>√â a vez de: <span id="current-turn-player"></span></div>
            </div>

            <div id="hints-section">
                <h3>Dicas:</h3>
                <div id="hints-list" class="hints-list"></div>

                <div id="hint-input-section" style="display: none;">
                    <div class="hint-input">
                        <label>Digite uma palavra (dica):</label>
                        <input type="text" id="hint-word" placeholder="Digite uma palavra" maxlength="50">
                        <button id="submit-hint" class="btn btn-block">Enviar Dica</button>
                    </div>
                </div>
            </div>

            <div id="palhaco-panel" class="palhaco-panel" style="display: none;">
                <h3>üé≠ Miss√£o Palha√ßo</h3>
                <p id="palhaco-status">Descubra os impostores em segredo durante a vota√ß√£o.</p>
                <ul id="palhaco-known-list" class="palhaco-known-list"></ul>
                <div id="palhaco-guess-section" style="display: none;">
                    <label for="palhaco-target">Quem voc√™ quer testar?</label>
                    <select id="palhaco-target"></select>
                    <button id="palhaco-guess-btn" class="btn btn-secondary" style="margin-top: 10px;">Enviar Palpite Secreto</button>
                    <div id="palhaco-feedback" class="nudge-meter-legend" style="margin-top: 8px;"></div>
                </div>
            </div>

            <div id="voting-section" class="voting-section" style="display: none;">
                <h3>Vota√ß√£o:</h3>
                <p>Escolha quem voc√™ acha que √© o impostor. WhiteMan eliminado ainda pode votar como fantasma.</p>
                <div id="vote-buttons"></div>
            </div>

            <div id="results-section" class="results-panel" style="display: none;">
                <h3>Resultado do Jogo:</h3>
                <div id="winner-message"></div>
                <div id="roles-reveal"></div>
                <div id="auto-delete-timer" class="timer-card" style="display: none;">
                    <strong>‚è∞ <span id="timer-text">A sala ser√° fechada automaticamente em 60 segundos...</span></strong>
                </div>
                <div id="game-actions"></div>
            </div>
        </div>
    </div>

    {% endif %}
</div>

<script>
const gameCode = '{{ game.code }}';
const playerName = '{{ player.name|default:"" }}';
const isSpectator = {% if is_spectator %}true{% else %}false{% endif %};
const POLL_INTERVAL_MS = 10000;
const stateUrl = `/api/game/${gameCode}/state/${isSpectator ? '?spectator=1' : ''}`;
const apiBaseUrl = `/api/game/${gameCode}`;
let pollTimer = null;
let isFetchingState = false;
let streamerMode = false;
let lastHintCount = 0;
let lastCurrentPlayer = null;

function playSound(frequency, duration, type = 'sine') {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
        console.log('Audio n√£o dispon√≠vel:', e);
    }
}

function playHintSound() {
    playSound(800, 0.1, 'sine');
    setTimeout(() => playSound(1000, 0.1, 'sine'), 50);
}

function playYourTurnSound() {
    playSound(600, 0.15, 'sine');
    setTimeout(() => playSound(800, 0.15, 'sine'), 100);
    setTimeout(() => playSound(1000, 0.2, 'sine'), 200);
}

function handlePlayerPing(element, targetPlayerName) {
    if (!element) {
        console.log('handlePlayerPing called with no element');
        return;
    }
    console.log('Sending nudge to:', targetPlayerName);
    
    // Visual feedback immediately
    playYourTurnSound();
    element.classList.add('pinged');
    setTimeout(() => element.classList.remove('pinged'), 400);
    
    // Send nudge to server so the target player receives it
    postAction('nudge', {
        player_name: playerName,
        target_player_name: targetPlayerName
    }).catch(() => {});
}

function attachPlayerPingHandlers() {
    const playersList = document.getElementById('players-list');
    if (!playersList) {
        return;
    }
    const currentTurnItems = playersList.querySelectorAll('.player-item.current-turn');
    console.log('Attaching ping handlers to', currentTurnItems.length, 'players with current turn');
    
    playersList.querySelectorAll('.player-item.current-turn').forEach(item => {
        // Remove old listeners by cloning (prevents duplicate listeners)
        const newItem = item.cloneNode(true);
        item.parentNode.replaceChild(newItem, item);
        
        const playerNameText = newItem.dataset.playerName || '';
        
        newItem.addEventListener('click', () => handlePlayerPing(newItem, playerNameText));
        newItem.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                handlePlayerPing(newItem, playerNameText);
            }
        });
    });
}

function handleRoomClosed(data) {
    if (pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
    }
    alert(data.message || 'A sala foi fechada.');
    const redirect = data.redirect || '/';
    window.location.href = redirect;
}

async function fetchGameState(showError = false) {
    if (isFetchingState) {
        return;
    }
    isFetchingState = true;
    try {
        const response = await fetch(stateUrl, {
            cache: 'no-store',
            credentials: 'same-origin'
        });
        if (!response.ok) {
            throw new Error('Falha ao buscar estado do jogo');
        }
        const data = await response.json();
        if (data.room_closed) {
            handleRoomClosed(data);
            return;
        }
        updateGameState(data);
    } catch (error) {
        console.error('Erro ao atualizar estado do jogo:', error);
        if (showError) {
            alert('N√£o foi poss√≠vel atualizar o estado do jogo. Verifique sua conex√£o.');
        }
    } finally {
        isFetchingState = false;
    }
}

async function postAction(action, payload) {
    try {
        const response = await fetch(`${apiBaseUrl}/${action}/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'same-origin',
            body: JSON.stringify(payload)
        });
        const data = await response.json();
        if (!response.ok || data.error) {
            throw new Error(data.error || 'Falha ao processar a√ß√£o');
        }
        if (data.room_closed) {
            handleRoomClosed(data);
            return data;
        }
        await fetchGameState();
        return data;
    } catch (error) {
        alert(error.message || 'Erro ao executar a√ß√£o.');
        throw error;
    }
}

function updatePalhacoPanel(state, players) {
    const panel = document.getElementById('palhaco-panel');
    if (!panel) {
        return;
    }

    if (isSpectator || !playerName) {
        panel.style.display = 'none';
        return;
    }

    const palhacoData = state.palhaco;
    if (!palhacoData) {
        panel.style.display = 'none';
        return;
    }

    panel.style.display = 'block';
    const statusEl = document.getElementById('palhaco-status');
    const knownListEl = document.getElementById('palhaco-known-list');
    const guessSection = document.getElementById('palhaco-guess-section');
    const guessSelect = document.getElementById('palhaco-target');
    const guessBtn = document.getElementById('palhaco-guess-btn');
    const feedbackEl = document.getElementById('palhaco-feedback');

    const remaining = palhacoData.remaining_impostors ?? Math.max(0, (palhacoData.total_impostors || 0) - (palhacoData.known_count || 0));
    let statusCopy = '';
    if (palhacoData.needs_elimination) {
        statusCopy = 'Voc√™ j√° encontrou todos os impostores. Agora tente ser eliminado para vencer sozinho!';
    } else if (remaining > 0) {
        statusCopy = `Descubra ${remaining} impostor${remaining === 1 ? '' : 'es'} em segredo.`;
    } else {
        statusCopy = 'Continue analisando as pistas e votes para encontrar impostores.';
    }
    statusEl.textContent = statusCopy;

    if (palhacoData.known_impostors && palhacoData.known_impostors.length > 0) {
        knownListEl.innerHTML = palhacoData.known_impostors.map(name => `<li>${name}</li>`).join('');
    } else {
        knownListEl.innerHTML = '<li>Voc√™ ainda n√£o confirmou ningu√©m.</li>';
    }

    if (palhacoData.can_guess) {
        const aliveTargets = players.filter(p => !p.is_eliminated && p.name !== playerName);
        if (aliveTargets.length === 0) {
            guessSection.style.display = 'none';
        } else {
            guessSection.style.display = 'block';
            guessSelect.innerHTML = '<option value="">Selecione um jogador</option>' + aliveTargets.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
            guessBtn.disabled = false;
            guessBtn.onclick = async () => {
                const targetName = guessSelect.value;
                if (!targetName) {
                    feedbackEl.textContent = 'Escolha algu√©m para testar.';
                    return;
                }
                guessBtn.disabled = true;
                feedbackEl.textContent = 'Enviando palpite secreto...';
                try {
                    const response = await postAction('palhaco-guess', {
                        player_name: playerName,
                        target_name: targetName,
                    });
                    if (response && response.message) {
                        feedbackEl.textContent = response.message;
                    } else {
                        feedbackEl.textContent = 'Palpite registrado!';
                    }
                } catch (error) {
                    feedbackEl.textContent = error.message || 'Erro ao enviar palpite.';
                }
            };
        }
    } else {
        guessSection.style.display = 'none';
        if (palhacoData.already_guessed_this_round) {
            feedbackEl.textContent = 'Voc√™ j√° fez seu palpite nesta rodada. Aguarde a pr√≥xima vota√ß√£o.';
        }
    }
}

function startPolling() {
    fetchGameState(true);
    if (pollTimer) {
        clearInterval(pollTimer);
    }
    pollTimer = setInterval(fetchGameState, POLL_INTERVAL_MS);
}

function updateGameState(state) {
    const game = state.game || {};
    const players = state.players || [];
    const hints = state.hints || [];
    const votes = state.votes || [];
    const nudges = state.nudges || [];
    const autoDeleteSeconds = state.auto_delete_seconds;

    // Handle nudges - play sound for each new nudge
    if (nudges.length > 0) {
        nudges.forEach(nudge => {
            console.log('Received nudge from:', nudge.from_player);
            playYourTurnSound();
            // Show a brief notification
            if (Notification && Notification.permission === 'granted') {
                new Notification('VATImposter', {
                    body: `${nudge.from_player} est√° chamando sua aten√ß√£o!`,
                    icon: '/static/icon.png'
                });
            }
        });
    }

    document.getElementById('game-status').textContent = getStatusText(game.status);
    document.getElementById('current-round').textContent = game.current_round;
    document.getElementById('player-count').textContent = players.length;
    const playerCountMax = document.getElementById('player-count-max');
    if (playerCountMax && game.max_players) {
        playerCountMax.textContent = game.max_players;
    }
    const nudgeMeterMax = game.nudge_meter_max || 100;

    // Controlar bot√µes de iniciar e reiniciar dinamicamente
    const currentPlayer = players.find(p => p.name === playerName);
    const gameControls = document.getElementById('game-controls');
    
    if (gameControls) {
        if (currentPlayer && currentPlayer.is_creator && !isSpectator) {
            if (game.status === 'waiting') {
                gameControls.innerHTML = `
                    <button id="start-btn" class="btn btn-block room-action">
                        Iniciar Jogo
                    </button>
                `;
                const startBtn = document.getElementById('start-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        postAction('start', { player_name: playerName }).catch(() => {});
                    });
                }
            } else if (game.status !== 'finished') {
                gameControls.innerHTML = `
                    <button id="restart-game-btn" class="btn btn-secondary btn-block room-action">
                        üîÑ Reiniciar Jogo
                    </button>
                `;
                const restartBtn = document.getElementById('restart-game-btn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', () => {
                        if (confirm('Deseja reiniciar o jogo? Todos receber√£o novas palavras e o jogo come√ßar√° do zero.')) {
                            postAction('restart', { player_name: playerName }).catch(() => {});
                        }
                    });
                }
            } else {
                gameControls.innerHTML = '';
            }
        } else {
            gameControls.innerHTML = '';
        }
    }

    const playersList = document.getElementById('players-list');
    const currentTurnPlayer = game.status === 'hints' ? game.current_player : null;
    const canKick = currentPlayer && currentPlayer.is_creator && !isSpectator && (game.status === 'waiting' || game.status === 'configuring');
    
    playersList.innerHTML = players.map(p => {
        let classes = 'player-item';
        if (p.is_creator) classes += ' creator';
        if (p.is_eliminated) classes += ' eliminated';
        if (currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated) {
            classes += ' current-turn';
        }
        // Destacar quem j√° votou
        if (game.status === 'voting' && votes.some(v => v.voter_name === p.name)) {
            classes += ' voted';
        }
        const eliminationIcon = p.is_eliminated ? ' <span class="danger-text">‚ùå</span>' : '';
        const whitemanBadge = p.role === 'whiteman' && p.is_eliminated ? ' <span class="whiteman-badge">‚ö™ WhiteMan</span>' : '';
        const clownBadge = p.role === 'clown' && p.is_eliminated ? ' <span class="clown-badge">üé≠ Palha√ßo</span>' : '';
        const isCurrentTurn = currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated;
        const interactiveAttrs = isCurrentTurn 
            ? `role="button" tabindex="0" aria-label="Alertar turno de ${p.name}" title="Tocar alerta para ${p.name}"`
            : '';
        const safeMax = nudgeMeterMax > 0 ? nudgeMeterMax : 100;
        const hpValue = typeof p.nudge_meter === 'number'
            ? Math.max(0, Math.min(p.nudge_meter, safeMax))
            : safeMax;
        const rawPercent = Math.round((hpValue / safeMax) * 100);
        const meterClass = rawPercent <= 20 ? 'is-danger' : rawPercent <= 50 ? 'is-warning' : '';
        const meterFill = `<div class="nudge-meter" aria-label="HP de ${p.name}: ${hpValue} de ${safeMax}">
                <div class="nudge-meter-track">
                    <div class="nudge-meter-fill ${meterClass}" style="width: ${rawPercent}%;"></div>
                </div>
                <span class="nudge-meter-value">${hpValue} HP</span>
            </div>`;
        
        // Bot√£o de kick apenas para o criador, na sala de espera, e n√£o para si mesmo
        const kickButton = canKick && p.name !== playerName 
            ? `<button class="btn-kick" data-player-name="${p.name}" title="Remover jogador">‚úï</button>`
            : '';
        
        return `<li class="${classes}" data-player-id="${p.id}" data-player-name="${p.name}" ${interactiveAttrs}>
            <div class="player-main-row">
                <span>${p.name}${eliminationIcon}${whitemanBadge}${clownBadge}</span>
                ${kickButton}
            </div>
            ${meterFill}
        </li>`;
    }).join('');
    
    // Adicionar event listeners para os bot√µes de kick
    if (canKick) {
        playersList.querySelectorAll('.btn-kick').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const targetName = btn.dataset.playerName;
                if (confirm(`Remover ${targetName} da sala?`)) {
                    postAction('kick', {
                        player_name: playerName,
                        target_player_name: targetName
                    }).catch(() => {});
                }
            });
        });
    }

    attachPlayerPingHandlers();
    updatePalhacoPanel(state, players);

    if (game.status !== 'waiting' && game.status !== 'configuring' && !isSpectator) {
        const player = players.find(p => p.name === playerName);
        if (player && player.role) {
            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');

            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                const displayRole = player.role === 'whiteman' ? 'citizen' : player.role;
                roleDisplay.innerHTML = `Seu papel: <span id="my-role">${getRoleText(displayRole)}</span>`;
                roleDisplay.style.display = 'block';

                if (player.role === 'whiteman') {
                    if (player.word) {
                        wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                    } else {
                        wordDisplay.style.display = 'none';
                    }
                } else if (player.role === 'impostor') {
                    wordDisplay.innerHTML = `<div class="danger-text">‚ö†Ô∏è VOC√ä √â O IMPOSTOR!</div><div>Sua palavra (diferente dos cidad√£os): <span id="my-word" class="danger-text">${player.word || 'N/A'}</span></div>`;
                } else if (player.role === 'clown') {
                    wordDisplay.innerHTML = `<div>üé≠ Voc√™ √© o Palha√ßo! Recebe a palavra dos impostores:</div><div><span id="my-word" class="danger-text">${player.word || 'N/A'}</span></div>`;
                } else if (player.word) {
                    wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                } else {
                    wordDisplay.style.display = 'none';
                }

                wordDisplay.style.display = 'block';
            }
        }
    }

    const hintsList = document.getElementById('hints-list');
    hintsList.innerHTML = hints.map(h => {
        return `<div class="hint-item">
            <strong>${h.player_name}</strong> (Rodada ${h.round_number}): ${h.word}
        </div>`;
    }).join('');

    if (hints.length > lastHintCount && game.status === 'hints') {
        playHintSound();
        // Scroll para a √∫ltima dica
        setTimeout(() => {
            hintsList.scrollTop = hintsList.scrollHeight;
        }, 50);
    }
    lastHintCount = hints.length;

    const currentTurnDisplay = document.getElementById('current-turn-display');
    const currentTurnPlayerSpan = document.getElementById('current-turn-player');
    if (game.status === 'hints' && game.current_player) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            currentTurnDisplay.style.display = 'block';
            currentTurnPlayerSpan.textContent = game.current_player;

            if (game.current_player === playerName && game.current_player !== lastCurrentPlayer) {
                playYourTurnSound();
            }
        } else {
            currentTurnDisplay.style.display = 'none';
        }
    } else {
        currentTurnDisplay.style.display = 'none';
    }
    lastCurrentPlayer = game.current_player;

    const hintInputSection = document.getElementById('hint-input-section');
    if (game.status === 'hints' && game.current_player === playerName && !isSpectator) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            hintInputSection.style.display = 'block';
        }
    } else {
        hintInputSection.style.display = 'none';
    }

    if (isSpectator) {
        document.getElementById('word-display').style.display = 'none';
        document.getElementById('role-display').style.display = 'none';
        document.getElementById('hint-input-section').style.display = 'none';
        document.getElementById('voting-section').style.display = 'none';
    }

    const votingSection = document.getElementById('voting-section');
    const voteTallies = state.vote_tallies || {};
    const currentRoundTally = voteTallies[game.current_round] || {};
    
    if (!isSpectator && game.status === 'voting') {
        votingSection.style.display = 'block';
        const activePlayers = players.filter(p => !p.is_eliminated && p.name !== playerName);
        const voteButtons = document.getElementById('vote-buttons');
        const hasVoted = votes.some(v => v.voter_name === playerName);
        
        // Show current vote counts if available
        let tallyDisplay = '';
        if (Object.keys(currentRoundTally).length > 0) {
            const sortedTally = Object.entries(currentRoundTally)
                .sort((a, b) => b[1] - a[1])
                .map(([name, count]) => `${name}: ${count} voto${count > 1 ? 's' : ''}`)
                .join(' | ');
            tallyDisplay = `<p style="margin: 10px 0; color: var(--text-300); font-size: 0.9rem;">üìä ${sortedTally}</p>`;
        }
        
        voteButtons.innerHTML = tallyDisplay + activePlayers.map(p => {
            return `<button class="vote-button ${hasVoted ? 'voted' : ''}" 
                    data-target="${p.name}" 
                    ${hasVoted ? 'disabled' : ''}>
                ${p.name}
            </button>`;
        }).join('');

        voteButtons.querySelectorAll('.vote-button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!btn.disabled) {
                    postAction('vote', {
                        player_name: playerName,
                        target_name: btn.dataset.target
                    }).catch(() => {});
                }
            });
        });
    } else {
        votingSection.style.display = 'none';
    }

    const resultsSection = document.getElementById('results-section');
    if (game.status === 'finished') {
        resultsSection.style.display = 'block';

        const impostors = players.filter(p => p.role === 'impostor');
        const activeImpostors = impostors.filter(p => !p.is_eliminated);

        const winnerTeam = game.winning_team;
        let winnerMessage = '';
        if (winnerTeam === 'clown') {
            winnerMessage = 'üé≠ Palha√ßo venceu sozinho!';
        } else if (winnerTeam === 'citizens') {
            winnerMessage = 'üèÜ Cidad√£os ganharam!';
        } else if (winnerTeam === 'impostors') {
            winnerMessage = 'üèÜ Impostores ganharam!';
        } else if (activeImpostors.length === 0) {
            winnerMessage = 'üèÜ Cidad√£os ganharam!';
        } else {
            winnerMessage = 'üèÜ Impostores ganharam!';
        }

        document.getElementById('winner-message').innerHTML = `<h2>${winnerMessage}</h2>`;

        const rolesReveal = document.getElementById('roles-reveal');
        rolesReveal.innerHTML = '<h3>Pap√©is revelados:</h3>' + 
            players.map(p => {
                const wordText = p.word ? ` (${p.word})` : '';
                const whitemanAlert = p.role === 'whiteman' && p.is_eliminated ? ' <span class="whiteman-badge">‚ö†Ô∏è Era WhiteMan!</span>' : '';
                return `<div class="player-item">
                    ${p.name}: ${getRoleText(p.role)}${wordText}${whitemanAlert}
                </div>`;
            }).join('');

        renderAutoDeleteTimer(autoDeleteSeconds);

        const currentPlayer = players.find(p => p.name === playerName);
        const gameActions = document.getElementById('game-actions');
        if (currentPlayer && currentPlayer.is_creator) {
            gameActions.innerHTML = `
                <button id="restart-btn" class="btn">
                    üîÑ Reiniciar Jogo
                </button>
                <button id="close-room-btn" class="btn btn-danger">
                    üóëÔ∏è Fechar Sala
                </button>
            `;

            const restartBtn = document.getElementById('restart-btn');
            const closeBtn = document.getElementById('close-room-btn');

            if (restartBtn) {
                restartBtn.onclick = () => {
                    if (confirm('Deseja reiniciar o jogo com os mesmos jogadores?')) {
                        postAction('restart', {
                            player_name: playerName
                        }).catch(() => {});
                    }
                };
            }

            if (closeBtn) {
                closeBtn.onclick = () => {
                    if (confirm('Tem certeza que deseja fechar a sala? Isso apagar√° todos os dados do jogo!')) {
                        postAction('close', {
                            player_name: playerName
                        }).catch(() => {});
                    }
                };
            }
        } else {
            gameActions.innerHTML = '<p>Aguardando o criador da sala reiniciar ou fechar...</p>';
        }
    } else {
        resultsSection.style.display = 'none';
        document.getElementById('winner-message').innerHTML = '';
        document.getElementById('roles-reveal').innerHTML = '';
        renderAutoDeleteTimer(null);
    }
}

function getStatusText(status) {
    const statusMap = {
        'waiting': 'Aguardando Jogadores',
        'configuring': 'Configurando',
        'hints': 'Rodada de Dicas',
        'voting': 'Vota√ß√£o',
        'finished': 'Finalizado'
    };
    return statusMap[status] || status;
}

function getRoleText(role) {
    const roleMap = {
        'citizen': 'Cidad√£o',
        'impostor': 'Impostor',
        'whiteman': 'WhiteMan',
        'clown': 'Palha√ßo'
    };
    return roleMap[role] || role;
}

function renderAutoDeleteTimer(remainingSeconds) {
    const timerDiv = document.getElementById('auto-delete-timer');
    const timerText = document.getElementById('timer-text');
    if (!timerDiv || !timerText) {
        return;
    }

    timerDiv.classList.remove('is-warning', 'is-danger');

    if (remainingSeconds === null || remainingSeconds === undefined) {
        timerDiv.style.display = 'none';
        timerText.textContent = '';
        return;
    }

    timerDiv.style.display = 'block';

    if (remainingSeconds <= 10) {
        timerDiv.classList.add('is-danger');
    } else if (remainingSeconds <= 20) {
        timerDiv.classList.add('is-warning');
    }

    if (remainingSeconds <= 0) {
        timerText.textContent = 'A sala ser√° fechada a qualquer momento...';
    } else {
        const label = remainingSeconds === 1 ? '1 segundo' : `${remainingSeconds} segundos`;
        timerText.textContent = `A sala ser√° fechada automaticamente em ${label}...`;
    }
}

if (playerName && !isSpectator) {
    const streamerToggle = document.getElementById('streamer-toggle');
    if (streamerToggle) {
        streamerToggle.addEventListener('click', () => {
            streamerMode = !streamerMode;
            document.body.classList.toggle('streamer-mode', streamerMode);
            streamerToggle.classList.toggle('active', streamerMode);
            streamerToggle.textContent = streamerMode ? 'üîì Modo Normal' : 'üì∫ Modo Streamer';

            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');
            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                fetchGameState(true);
            }
        });
    }
}

if (playerName && !isSpectator) {
    const submitHintBtn = document.getElementById('submit-hint');
    const hintInput = document.getElementById('hint-word');

    if (submitHintBtn && hintInput) {
        submitHintBtn.addEventListener('click', async () => {
            const word = hintInput.value.trim();
            if (!word) {
                return;
            }
            submitHintBtn.disabled = true;
            try {
                await postAction('hint', {
                    player_name: playerName,
                    word: word
                });
                hintInput.value = '';
            } catch (error) {
                console.error('Erro ao enviar dica:', error);
            } finally {
                submitHintBtn.disabled = false;
            }
        });

        hintInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitHintBtn.click();
            }
        });
    }
}

if (playerName || isSpectator) {
    startPolling();
    window.addEventListener('beforeunload', () => {
        if (pollTimer) {
            clearInterval(pollTimer);
        }
    });
}

// Share Link button
const shareLinkBtn = document.getElementById('share-link-btn');
if (shareLinkBtn) {
    shareLinkBtn.addEventListener('click', async () => {
        const shareUrl = `${window.location.origin}/join/?code=${gameCode}`;
        
        try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(shareUrl);
                shareLinkBtn.textContent = '‚úÖ Link Copiado!';
                shareLinkBtn.classList.add('copied');
                
                setTimeout(() => {
                    shareLinkBtn.textContent = 'üîó Compartilhar Link';
                    shareLinkBtn.classList.remove('copied');
                }, 2000);
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = shareUrl;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                shareLinkBtn.textContent = '‚úÖ Link Copiado!';
                shareLinkBtn.classList.add('copied');
                
                setTimeout(() => {
                    shareLinkBtn.textContent = 'üîó Compartilhar Link';
                    shareLinkBtn.classList.remove('copied');
                }, 2000);
            }
        } catch (err) {
            console.error('Erro ao copiar link:', err);
            alert(`Link para compartilhar:\n${shareUrl}`);
        }
    });
}
</script>
{% endblock %}


