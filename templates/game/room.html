{% extends 'base.html' %}

{% block title %}Sala {{ game.code }} - VAT Imposter{% endblock %}

{% block extra_css %}
<style>
    .room-container {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 20px;
    }
    
    @media (max-width: 768px) {
        .room-container {
            grid-template-columns: 1fr;
        }
    }
    
    .players-list {
        list-style: none;
    }
    
    .player-item {
        padding: 10px;
        margin: 5px 0;
        background: #f5f5f5;
        border-radius: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .player-item.eliminated {
        opacity: 0.5;
        text-decoration: line-through;
    }
    
    .player-item.creator::after {
        content: " üëë";
    }
    
    .game-status {
        padding: 15px;
        background: #e3f2fd;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    .hint-input {
        margin: 20px 0;
    }
    
    .hints-list {
        max-height: 400px;
        overflow-y: auto;
        margin-top: 20px;
    }
    
    .hint-item {
        padding: 10px;
        margin: 5px 0;
        background: #f9f9f9;
        border-left: 4px solid #667eea;
        border-radius: 4px;
    }
    
    .voting-section {
        margin-top: 20px;
    }
    
    .vote-button {
        width: 100%;
        margin: 5px 0;
        padding: 10px;
        background: #fff;
        border: 2px solid #667eea;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .vote-button:hover {
        background: #667eea;
        color: white;
    }
    
    .vote-button.voted {
        background: #667eea;
        color: white;
    }
    
    .word-display {
        padding: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 8px;
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        margin: 20px 0;
    }
    
    .role-display {
        padding: 10px;
        background: #fff3cd;
        border-radius: 8px;
        margin: 10px 0;
        text-align: center;
        font-weight: bold;
    }
    
    .current-turn-display {
        padding: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 8px;
        margin: 20px 0;
        text-align: center;
        font-size: 18px;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .player-item.current-turn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-weight: bold;
        transform: scale(1.05);
        box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
    }
    
    .player-item.current-turn::before {
        content: "üëâ ";
    }
    
    .streamer-mode .word-display,
    .streamer-mode .role-display {
        display: none !important;
    }
    
    .streamer-mode .word-display::before {
        content: "üîí Informa√ß√£o Ocultada";
    }
    
    .streamer-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        background: rgba(102, 126, 234, 0.9);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .streamer-toggle:hover {
        background: rgba(102, 126, 234, 1);
    }
    
    .streamer-toggle.active {
        background: rgba(245, 87, 108, 0.9);
    }
    
    .spectator-badge {
        background: #f5576c;
        color: white;
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        display: inline-block;
        margin-left: 10px;
    }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h1>Sala: {{ game.code }}{% if is_spectator %}<span class="spectator-badge">üëÅÔ∏è ESPECTADOR</span>{% endif %}</h1>
    
    {% if not player and not is_spectator %}
    <div class="error">
        Voc√™ n√£o est√° nesta sala. Por favor, entre com seu nome.
    </div>
    {% else %}
    
    {% if player %}
    <button id="streamer-toggle" class="streamer-toggle" title="Modo Streamer - Oculta palavra e fun√ß√£o">
        üì∫ Modo Streamer
    </button>
    {% endif %}
    
    <div class="room-container">
        <div>
            <div class="game-status">
                <h3>Status: <span id="game-status">{{ game.get_status_display }}</span></h3>
                <p>Rodada: <span id="current-round">{{ game.current_round }}</span></p>
                <p>Jogadores: <span id="player-count">{{ game.players.count }}</span>/{{ game.max_players }}</p>
            </div>
            
            <h3>Jogadores:</h3>
            <ul class="players-list" id="players-list">
                {% for p in players %}
                <li class="player-item {% if p.is_creator %}creator{% endif %} {% if p.is_eliminated %}eliminated{% endif %}" data-player-id="{{ p.id }}">
                    {{ p.name }}
                    {% if p.is_eliminated %}<span style="color: red;">‚ùå</span>{% endif %}
                </li>
                {% endfor %}
            </ul>
            
            {% if player.is_creator and game.status == 'waiting' %}
            <button id="start-btn" class="btn" style="width: 100%; margin-top: 20px;">
                Iniciar Jogo
            </button>
            {% endif %}
        </div>
        
        <div>
            <div id="word-display" class="word-display" style="display: none;">
                <div>Sua palavra: <span id="my-word"></span></div>
            </div>
            
            <div id="role-display" class="role-display" style="display: none;">
                Seu papel: <span id="my-role"></span>
            </div>
            
            <div id="current-turn-display" class="current-turn-display" style="display: none;">
                <div>√â a vez de: <span id="current-turn-player"></span></div>
            </div>
            
            <div id="hints-section">
                <h3>Dicas:</h3>
                <div id="hints-list" class="hints-list"></div>
                
                <div id="hint-input-section" style="display: none;">
                    <div class="hint-input">
                        <label>Digite uma palavra (dica):</label>
                        <input type="text" id="hint-word" placeholder="Digite uma palavra" maxlength="50">
                        <button id="submit-hint" class="btn" style="width: 100%; margin-top: 10px;">Enviar Dica</button>
                    </div>
                </div>
            </div>
            
            <div id="voting-section" class="voting-section" style="display: none;">
                <h3>Vota√ß√£o:</h3>
                <p>Escolha quem voc√™ acha que √© o impostor:</p>
                <div id="vote-buttons"></div>
            </div>
            
            <div id="results-section" style="display: none;">
                <h3>Resultado do Jogo:</h3>
                <div id="winner-message"></div>
                <div id="roles-reveal"></div>
                <div id="auto-delete-timer" style="margin: 20px 0; padding: 15px; background: #fff3cd; border-radius: 8px; text-align: center; display: none;">
                    <strong style="color: #f5576c;">‚è∞ <span id="timer-text">A sala ser√° fechada automaticamente em 60 segundos...</span></strong>
                </div>
                <div id="game-actions" style="margin-top: 20px; text-align: center;">
                    <!-- Bot√µes aparecer√£o aqui apenas para o criador -->
                </div>
            </div>
        </div>
    </div>
    
    {% endif %}
</div>

<script>
const gameCode = '{{ game.code }}';
const playerName = '{{ player.name|default:"" }}';
const isSpectator = {{ 'true' if is_spectator else 'false' }};
let ws = null;
let streamerMode = false;
let lastHintCount = 0;
let lastCurrentPlayer = null;

// Fun√ß√£o para gerar sons usando Web Audio API
function playSound(frequency, duration, type = 'sine') {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
        console.log('Audio n√£o dispon√≠vel:', e);
    }
}

// Som quando algu√©m d√° dica (som curto e agudo)
function playHintSound() {
    playSound(800, 0.1, 'sine');
    setTimeout(() => playSound(1000, 0.1, 'sine'), 50);
}

// Som quando √© sua vez (som mais longo e diferente)
function playYourTurnSound() {
    playSound(600, 0.15, 'sine');
    setTimeout(() => playSound(800, 0.15, 'sine'), 100);
    setTimeout(() => playSound(1000, 0.2, 'sine'), 200);
}

function connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/game/${gameCode}/`;
    
    ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
        console.log('Conectado ao WebSocket');
        sendMessage({ type: 'get_state' });
    };
    
    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleMessage(data);
    };
    
    ws.onerror = (error) => {
        console.error('Erro no WebSocket:', error);
    };
    
    ws.onclose = () => {
        console.log('Desconectado do WebSocket');
        setTimeout(connectWebSocket, 3000);
    };
}

function sendMessage(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    }
}

let autoDeleteTimer = null;

function handleMessage(data) {
    if (data.type === 'game_state') {
        updateGameState(data);
    } else if (data.type === 'error') {
        alert(data.message);
    } else if (data.type === 'game_restarted') {
        // Cancelar timer se existir
        if (autoDeleteTimer) {
            clearInterval(autoDeleteTimer);
            autoDeleteTimer = null;
        }
        document.getElementById('auto-delete-timer').style.display = 'none';
        alert(data.message || 'O jogo foi reiniciado!');
        // Recarregar estado
        sendMessage({ type: 'get_state' });
    } else if (data.type === 'auto_delete_countdown') {
        // Atualizar contador visual
        const timerDiv = document.getElementById('auto-delete-timer');
        const timerText = document.getElementById('timer-text');
        if (timerDiv && timerText) {
            timerDiv.style.display = 'block';
            const seconds = data.seconds_remaining || 60;
            timerText.textContent = `A sala ser√° fechada automaticamente em ${seconds} segundos...`;
            
            // Mudar cor quando estiver acabando
            if (seconds <= 10) {
                timerDiv.style.background = '#fee';
                timerText.style.color = '#c33';
            } else if (seconds <= 30) {
                timerDiv.style.background = '#fff3cd';
                timerText.style.color = '#f5576c';
            }
        }
    } else if (data.type === 'room_closed') {
        // Cancelar timer se existir
        if (autoDeleteTimer) {
            clearInterval(autoDeleteTimer);
            autoDeleteTimer = null;
        }
        alert(data.message || 'A sala foi fechada.');
        if (data.redirect) {
            setTimeout(() => {
                window.location.href = data.redirect;
            }, 1000);
        }
    }
}

function updateGameState(state) {
    const game = state.game;
    const players = state.players;
    const hints = state.hints;
    const votes = state.votes;
    
    // Atualizar status
    document.getElementById('game-status').textContent = getStatusText(game.status);
    document.getElementById('current-round').textContent = game.current_round;
    document.getElementById('player-count').textContent = players.length;
    
    // Atualizar lista de jogadores
    const playersList = document.getElementById('players-list');
    const currentTurnPlayer = game.status === 'hints' ? game.current_player : null;
    playersList.innerHTML = players.map(p => {
        let classes = 'player-item';
        if (p.is_creator) classes += ' creator';
        if (p.is_eliminated) classes += ' eliminated';
        if (currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated) {
            classes += ' current-turn';
        }
        return `<li class="${classes}" data-player-id="${p.id}">
            ${p.name}${p.is_eliminated ? ' <span style="color: red;">‚ùå</span>' : ''}
        </li>`;
    }).join('');
    
    // Mostrar palavra e papel se o jogo come√ßou (n√£o para espectadores)
    if (game.status !== 'waiting' && game.status !== 'configuring' && !isSpectator) {
        const player = players.find(p => p.name === playerName);
        if (player && player.role) {
            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');
            
            // Aplicar modo streamer se ativado
            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                // SEMPRE mostrar o papel do jogador desde o in√≠cio
                roleDisplay.innerHTML = `Seu papel: <span id="my-role">${getRoleText(player.role)}</span>`;
                roleDisplay.style.display = 'block';
                
                // Mostrar palavra baseado no papel
                if (player.role === 'whiteman') {
                    wordDisplay.innerHTML = '<div style="color: #f5576c; font-weight: bold;">Voc√™ √© o WhiteMan - N√£o recebeu palavra!</div>';
                } else if (player.role === 'impostor') {
                    wordDisplay.innerHTML = `<div style="color: #f5576c; font-weight: bold;">‚ö†Ô∏è VOC√ä √â O IMPOSTOR!</div><div>Sua palavra (diferente dos cidad√£os): <span id="my-word" style="color: #f5576c; font-weight: bold;">${player.word || 'N/A'}</span></div>`;
                } else if (player.word) {
                    wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                } else {
                    wordDisplay.style.display = 'none';
                }
                
                wordDisplay.style.display = 'block';
            }
        }
    }
    
    // Atualizar dicas
    const hintsList = document.getElementById('hints-list');
    hintsList.innerHTML = hints.map(h => {
        return `<div class="hint-item">
            <strong>${h.player_name}</strong> (Rodada ${h.round_number}): ${h.word}
        </div>`;
    }).join('');
    
    // Tocar som quando algu√©m d√° dica (se o n√∫mero de dicas aumentou)
    if (hints.length > lastHintCount && game.status === 'hints') {
        playHintSound();
    }
    lastHintCount = hints.length;
    
    // Mostrar de quem √© a vez (vis√≠vel para TODOS os jogadores)
    const currentTurnDisplay = document.getElementById('current-turn-display');
    const currentTurnPlayerSpan = document.getElementById('current-turn-player');
    if (game.status === 'hints' && game.current_player) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            currentTurnDisplay.style.display = 'block';
            currentTurnPlayerSpan.textContent = game.current_player;
            
            // Tocar som quando √© sua vez (se mudou)
            if (game.current_player === playerName && game.current_player !== lastCurrentPlayer) {
                playYourTurnSound();
            }
        } else {
            currentTurnDisplay.style.display = 'none';
        }
    } else {
        currentTurnDisplay.style.display = 'none';
    }
    lastCurrentPlayer = game.current_player;
    
    // Gerenciar se√ß√£o de dicas (apenas para o jogador da vez)
    const hintInputSection = document.getElementById('hint-input-section');
    if (game.status === 'hints' && game.current_player === playerName && !isSpectator) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            hintInputSection.style.display = 'block';
        }
    } else {
        hintInputSection.style.display = 'none';
    }
    
    // Modo espectador: esconder informa√ß√µes sens√≠veis
    if (isSpectator) {
        document.getElementById('word-display').style.display = 'none';
        document.getElementById('role-display').style.display = 'none';
        document.getElementById('hint-input-section').style.display = 'none';
        document.getElementById('voting-section').style.display = 'none';
    }
    
    // Gerenciar vota√ß√£o
    const votingSection = document.getElementById('voting-section');
    if (game.status === 'voting') {
        votingSection.style.display = 'block';
        const activePlayers = players.filter(p => !p.is_eliminated && p.name !== playerName);
        const voteButtons = document.getElementById('vote-buttons');
        voteButtons.innerHTML = activePlayers.map(p => {
            const hasVoted = votes.some(v => v.voter_name === playerName);
            return `<button class="vote-button ${hasVoted ? 'voted' : ''}" 
                    data-target="${p.name}" 
                    ${hasVoted ? 'disabled' : ''}>
                ${p.name}
            </button>`;
        }).join('');
        
        // Adicionar listeners aos bot√µes de voto
        voteButtons.querySelectorAll('.vote-button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!btn.disabled) {
                    sendMessage({
                        type: 'submit_vote',
                        player_name: playerName,
                        target_name: btn.dataset.target
                    });
                }
            });
        });
    } else {
        votingSection.style.display = 'none';
    }
    
    // Mostrar resultados se o jogo terminou
    if (game.status === 'finished') {
        const resultsSection = document.getElementById('results-section');
        resultsSection.style.display = 'block';
        
        // Determinar vencedor
        const impostors = players.filter(p => p.role === 'impostor');
        const activeImpostors = impostors.filter(p => !p.is_eliminated);
        
        let winnerMessage = '';
        if (activeImpostors.length === 0) {
            winnerMessage = 'üèÜ Cidad√£os ganharam!';
        } else {
            winnerMessage = 'üèÜ Impostores ganharam!';
        }
        
        document.getElementById('winner-message').innerHTML = `<h2>${winnerMessage}</h2>`;
        
        // Revelar pap√©is
        const rolesReveal = document.getElementById('roles-reveal');
        rolesReveal.innerHTML = '<h3>Pap√©is revelados:</h3>' + 
            players.map(p => {
                const wordText = p.word ? ` (${p.word})` : '';
                return `<div class="player-item">
                    ${p.name}: ${getRoleText(p.role)}${wordText}
                </div>`;
            }).join('');
        
        // Mostrar timer e bot√µes de a√ß√£o
        const timerDiv = document.getElementById('auto-delete-timer');
        if (timerDiv) {
            timerDiv.style.display = 'block';
        }
        
        // Mostrar bot√µes de a√ß√£o apenas para o criador
        const currentPlayer = players.find(p => p.name === playerName);
        const gameActions = document.getElementById('game-actions');
        if (currentPlayer && currentPlayer.is_creator) {
            // Remover listeners antigos se existirem
            const oldRestartBtn = document.getElementById('restart-btn');
            const oldCloseBtn = document.getElementById('close-room-btn');
            if (oldRestartBtn) oldRestartBtn.remove();
            if (oldCloseBtn) oldCloseBtn.remove();
            
            gameActions.innerHTML = `
                <button id="restart-btn" class="btn" style="margin-right: 10px;">
                    üîÑ Reiniciar Jogo
                </button>
                <button id="close-room-btn" class="btn btn-danger">
                    üóëÔ∏è Fechar Sala
                </button>
            `;
            
            const restartBtn = document.getElementById('restart-btn');
            const closeBtn = document.getElementById('close-room-btn');
            
            if (restartBtn) {
                restartBtn.onclick = () => {
                    if (confirm('Deseja reiniciar o jogo com os mesmos jogadores?')) {
                        sendMessage({
                            type: 'restart_game',
                            player_name: playerName
                        });
                    }
                };
            }
            
            if (closeBtn) {
                closeBtn.onclick = () => {
                    if (confirm('Tem certeza que deseja fechar a sala? Isso apagar√° todos os dados do jogo!')) {
                        sendMessage({
                            type: 'close_room',
                            player_name: playerName
                        });
                    }
                };
            }
        } else {
            gameActions.innerHTML = '<p>Aguardando o criador da sala reiniciar ou fechar...</p>';
        }
    }
}

function getStatusText(status) {
    const statusMap = {
        'waiting': 'Aguardando Jogadores',
        'configuring': 'Configurando',
        'hints': 'Rodada de Dicas',
        'voting': 'Vota√ß√£o',
        'finished': 'Finalizado'
    };
    return statusMap[status] || status;
}

function getRoleText(role) {
    const roleMap = {
        'citizen': 'Cidad√£o',
        'impostor': 'Impostor',
        'whiteman': 'WhiteMan'
    };
    return roleMap[role] || role;
}

// Modo Streamer - Toggle
if (playerName && !isSpectator) {
    const streamerToggle = document.getElementById('streamer-toggle');
    if (streamerToggle) {
        streamerToggle.addEventListener('click', () => {
            streamerMode = !streamerMode;
            document.body.classList.toggle('streamer-mode', streamerMode);
            streamerToggle.classList.toggle('active', streamerMode);
            streamerToggle.textContent = streamerMode ? 'üîì Modo Normal' : 'üì∫ Modo Streamer';
            
            // Atualizar display de palavra/role
            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');
            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                // Recarregar estado do jogo para mostrar novamente
                sendMessage({ type: 'get_state' });
            }
        });
    }
}

// Event listeners
if (playerName && !isSpectator) {
    document.getElementById('start-btn')?.addEventListener('click', () => {
        sendMessage({
            type: 'start_game',
            player_name: playerName
        });
    });
    
    document.getElementById('submit-hint')?.addEventListener('click', () => {
        const word = document.getElementById('hint-word').value.trim();
        if (word) {
            sendMessage({
                type: 'submit_hint',
                player_name: playerName,
                word: word
            });
            document.getElementById('hint-word').value = '';
        }
    });
    
    document.getElementById('hint-word')?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('submit-hint').click();
        }
    });
}

// Conectar WebSocket (para jogadores e espectadores)
if (playerName || isSpectator) {
    connectWebSocket();
}
</script>
{% endblock %}

