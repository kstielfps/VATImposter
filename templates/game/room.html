{% extends 'base.html' %}

{% block title %}Sala {{ game.code }} - VATGames{% endblock %}

{% block extra_css %}
<style>
    .room-container {
        display: grid;
        grid-template-columns: minmax(280px, 1fr) minmax(420px, 2fr);
        gap: 32px;
        align-items: start;
    }

    @media (max-width: 960px) {
        .room-container {
            grid-template-columns: 1fr;
            gap: 24px;
        }
    }

    .room-panel {
        display: flex;
        flex-direction: column;
        gap: 24px;
    }

    .game-status {
        padding: 20px;
        border-radius: 20px;
        background: rgba(12, 16, 24, 0.85);
        border: 1px solid rgba(77, 212, 255, 0.12);
        display: grid;
        gap: 10px;
    }

    .game-status span {
        font-weight: 600;
        color: var(--text-100);
    }

    .players-list {
        margin-top: 12px;
    }

    .player-item.current-turn {
        cursor: pointer;
        transition: transform 0.15s ease, border-color 0.15s ease;
    }

    .player-item.current-turn:focus-visible {
        outline: 2px solid var(--accent-500);
        outline-offset: 2px;
    }

    .player-item.current-turn.pinged {
        border-color: rgba(77, 212, 255, 0.8);
        box-shadow: 0 0 0 2px rgba(77, 212, 255, 0.25);
        transform: translateX(2px);
    }

    .player-item.voted {
        border-color: rgba(45, 211, 111, 0.6);
        background: linear-gradient(120deg, rgba(45, 211, 111, 0.15), rgba(26, 32, 44, 0.85));
    }

    .room-action {
        margin-top: 16px;
    }

    .hint-input {
        margin-top: 20px;
    }

    .hint-input label {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.85rem;
        color: var(--text-300);
    }

    .hint-input .btn {
        margin-top: 12px;
    }

    #vote-buttons {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-top: 12px;
    }

    #results-section {
        margin-top: 32px;
    }

    .timer-card {
        margin: 20px 0;
        padding: 15px 18px;
        border-radius: 18px;
        background: rgba(244, 180, 0, 0.14);
        border: 1px solid rgba(244, 180, 0, 0.45);
        text-align: center;
        transition: border-color 0.2s ease, background 0.2s ease;
    }

    .timer-card.is-warning {
        background: rgba(244, 180, 0, 0.25);
        border-color: rgba(244, 180, 0, 0.65);
    }

    .timer-card.is-danger {
        background: rgba(255, 77, 109, 0.18);
        border-color: rgba(255, 77, 109, 0.65);
    }

    #game-actions {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 12px;
    }

    .danger-text {
        color: var(--danger-500);
        font-weight: 600;
    }

    .btn-kick {
        background: rgba(255, 77, 109, 0.15);
        border: 1px solid rgba(255, 77, 109, 0.4);
        color: var(--danger-500);
        border-radius: 8px;
        padding: 4px 10px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.2s ease;
        margin-left: auto;
    }

    .btn-kick:hover {
        background: rgba(255, 77, 109, 0.3);
        border-color: rgba(255, 77, 109, 0.6);
        transform: scale(1.05);
    }

    .player-item {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .player-item > span:first-child {
        flex: 1;
    }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h1>Sala: {{ game.code }}{% if is_spectator %}<span class="spectator-badge">üëÅÔ∏è ESPECTADOR</span>{% endif %}</h1>

    {% if not player and not is_spectator %}
    <div class="error">
        Voc√™ n√£o est√° nesta sala. Por favor, entre com seu nome.
    </div>
    {% else %}

    {% if player %}
    <button id="streamer-toggle" class="streamer-toggle" title="Modo Streamer - Oculta palavra e fun√ß√£o">
        üì∫ Modo Streamer
    </button>
    {% endif %}

    <div class="room-container">
        <div class="room-panel">
            <div class="game-status">
                <h3>Status: <span id="game-status">{{ game.get_status_display }}</span></h3>
                <p>Rodada: <span id="current-round">{{ game.current_round }}</span></p>
                <p>Jogadores: <span id="player-count">{{ game.players.count }}</span>/{{ game.max_players }}</p>
            </div>

            <div>
                <h3>Jogadores:</h3>
                <ul class="players-list" id="players-list">
                    {% for p in players %}
                    <li class="player-item{% if p.is_creator %} creator{% endif %}{% if p.is_eliminated %} eliminated{% endif %}" data-player-id="{{ p.id }}">
                        {{ p.name }}
                        {% if p.is_eliminated %}<span class="danger-text">‚ùå</span>{% endif %}
                    </li>
                    {% endfor %}
                </ul>
            </div>

            <div id="game-controls"></div>
        </div>

        <div class="room-panel">
            <div id="word-display" class="word-display" style="display: none;">
                <div>Sua palavra: <span id="my-word"></span></div>
            </div>

            <div id="role-display" class="role-display" style="display: none;">
                Seu papel: <span id="my-role"></span>
            </div>

            <div id="current-turn-display" class="current-turn-display" style="display: none;">
                <div>√â a vez de: <span id="current-turn-player"></span></div>
            </div>

            <div id="hints-section">
                <h3>Dicas:</h3>
                <div id="hints-list" class="hints-list"></div>

                <div id="hint-input-section" style="display: none;">
                    <div class="hint-input">
                        <label>Digite uma palavra (dica):</label>
                        <input type="text" id="hint-word" placeholder="Digite uma palavra" maxlength="50">
                        <button id="submit-hint" class="btn btn-block">Enviar Dica</button>
                    </div>
                </div>
            </div>

            <div id="voting-section" class="voting-section" style="display: none;">
                <h3>Vota√ß√£o:</h3>
                <p>Escolha quem voc√™ acha que √© o impostor:</p>
                <div id="vote-buttons"></div>
            </div>

            <div id="results-section" class="results-panel" style="display: none;">
                <h3>Resultado do Jogo:</h3>
                <div id="winner-message"></div>
                <div id="roles-reveal"></div>
                <div id="auto-delete-timer" class="timer-card" style="display: none;">
                    <strong>‚è∞ <span id="timer-text">A sala ser√° fechada automaticamente em 60 segundos...</span></strong>
                </div>
                <div id="game-actions"></div>
            </div>
        </div>
    </div>

    {% endif %}
</div>

<script>
const gameCode = '{{ game.code }}';
const playerName = '{{ player.name|default:"" }}';
const isSpectator = {% if is_spectator %}true{% else %}false{% endif %};
let ws = null;
let streamerMode = false;
let lastHintCount = 0;
let lastCurrentPlayer = null;

function playSound(frequency, duration, type = 'sine') {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
        console.log('Audio n√£o dispon√≠vel:', e);
    }
}

function playHintSound() {
    playSound(800, 0.1, 'sine');
    setTimeout(() => playSound(1000, 0.1, 'sine'), 50);
}

function playYourTurnSound() {
    playSound(600, 0.15, 'sine');
    setTimeout(() => playSound(800, 0.15, 'sine'), 100);
    setTimeout(() => playSound(1000, 0.2, 'sine'), 200);
}

function handlePlayerPing(element) {
    if (!element) {
        return;
    }
    playYourTurnSound();
    element.classList.add('pinged');
    setTimeout(() => element.classList.remove('pinged'), 400);
}

function attachPlayerPingHandlers() {
    const playersList = document.getElementById('players-list');
    if (!playersList) {
        return;
    }
    playersList.querySelectorAll('.player-item.current-turn').forEach(item => {
        item.addEventListener('click', () => handlePlayerPing(item));
        item.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                handlePlayerPing(item);
            }
        });
    });
}

function connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/game/${gameCode}/`;

    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
        sendMessage({ type: 'get_state' });
    };

    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleMessage(data);
    };

    ws.onerror = (error) => {
        console.error('Erro no WebSocket:', error);
    };

    ws.onclose = () => {
        setTimeout(connectWebSocket, 3000);
    };
}

function sendMessage(data) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(data));
    }
}

let autoDeleteTimer = null;

function handleMessage(data) {
    if (data.type === 'game_state') {
        updateGameState(data);
    } else if (data.type === 'error') {
        alert(data.message);
    } else if (data.type === 'game_restarted') {
        if (autoDeleteTimer) {
            clearInterval(autoDeleteTimer);
            autoDeleteTimer = null;
        }
        document.getElementById('auto-delete-timer').style.display = 'none';
        alert(data.message || 'O jogo foi reiniciado!');
        sendMessage({ type: 'get_state' });
    } else if (data.type === 'auto_delete_countdown') {
        const timerDiv = document.getElementById('auto-delete-timer');
        const timerText = document.getElementById('timer-text');
        if (timerDiv && timerText) {
            timerDiv.style.display = 'block';
            timerDiv.classList.remove('is-warning', 'is-danger');
            const seconds = data.seconds_remaining || 60;
            timerText.textContent = `A sala ser√° fechada automaticamente em ${seconds} segundos...`;

            if (seconds <= 10) {
                timerDiv.classList.add('is-danger');
            } else if (seconds <= 30) {
                timerDiv.classList.add('is-warning');
            }
        }
    } else if (data.type === 'room_closed') {
        if (autoDeleteTimer) {
            clearInterval(autoDeleteTimer);
            autoDeleteTimer = null;
        }
        alert(data.message || 'A sala foi fechada.');
        if (data.redirect) {
            setTimeout(() => {
                window.location.href = data.redirect;
            }, 1000);
        }
    }
}

function updateGameState(state) {
    const game = state.game;
    const players = state.players;
    const hints = state.hints;
    const votes = state.votes;

    document.getElementById('game-status').textContent = getStatusText(game.status);
    document.getElementById('current-round').textContent = game.current_round;
    document.getElementById('player-count').textContent = players.length;

    // Controlar bot√µes de iniciar e reiniciar dinamicamente
    const currentPlayer = players.find(p => p.name === playerName);
    const gameControls = document.getElementById('game-controls');
    
    if (currentPlayer && currentPlayer.is_creator && !isSpectator && gameControls) {
        if (game.status === 'waiting') {
            // Mostrar bot√£o de iniciar
            gameControls.innerHTML = `
                <button id="start-btn" class="btn btn-block room-action">
                    Iniciar Jogo
                </button>
            `;
            
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.onclick = () => {
                    sendMessage({
                        type: 'start_game',
                        player_name: playerName
                    });
                };
            }
        } else if (game.status !== 'finished') {
            // Mostrar bot√£o de reiniciar durante o jogo
            gameControls.innerHTML = `
                <button id="restart-game-btn" class="btn btn-secondary btn-block room-action">
                    üîÑ Reiniciar Jogo
                </button>
            `;
            
            const restartBtn = document.getElementById('restart-game-btn');
            if (restartBtn) {
                restartBtn.onclick = () => {
                    if (confirm('Deseja reiniciar o jogo? Todos receber√£o novas palavras e o jogo come√ßar√° do zero.')) {
                        sendMessage({
                            type: 'restart_game',
                            player_name: playerName
                        });
                    }
                };
            }
        } else {
            // Limpar bot√µes quando o jogo terminou
            gameControls.innerHTML = '';
        }
    }

    const playersList = document.getElementById('players-list');
    const currentTurnPlayer = game.status === 'hints' ? game.current_player : null;
    const canKick = currentPlayer && currentPlayer.is_creator && !isSpectator && (game.status === 'waiting' || game.status === 'configuring');
    
    playersList.innerHTML = players.map(p => {
        let classes = 'player-item';
        if (p.is_creator) classes += ' creator';
        if (p.is_eliminated) classes += ' eliminated';
        if (currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated) {
            classes += ' current-turn';
        }
        // Destacar quem j√° votou
        if (game.status === 'voting' && votes.some(v => v.voter_name === p.name)) {
            classes += ' voted';
        }
        const eliminationIcon = p.is_eliminated ? ' <span class="danger-text">‚ùå</span>' : '';
        const whitemanBadge = p.role === 'whiteman' && p.is_eliminated ? ' <span class="whiteman-badge">‚ö™ WhiteMan</span>' : '';
        const isCurrentTurn = currentTurnPlayer && p.name === currentTurnPlayer && !p.is_eliminated;
        const interactiveAttrs = isCurrentTurn 
            ? `role="button" tabindex="0" aria-label="Alertar turno de ${p.name}" title="Tocar alerta para ${p.name}"`
            : '';
        
        // Bot√£o de kick apenas para o criador, na sala de espera, e n√£o para si mesmo
        const kickButton = canKick && p.name !== playerName 
            ? `<button class="btn-kick" data-player-name="${p.name}" title="Remover jogador">‚úï</button>`
            : '';
        
        return `<li class="${classes}" data-player-id="${p.id}" ${interactiveAttrs}>
            <span>${p.name}${eliminationIcon}${whitemanBadge}</span>
            ${kickButton}
        </li>`;
    }).join('');
    
    // Adicionar event listeners para os bot√µes de kick
    if (canKick) {
        playersList.querySelectorAll('.btn-kick').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const targetName = btn.dataset.playerName;
                if (confirm(`Remover ${targetName} da sala?`)) {
                    sendMessage({
                        type: 'kick_player',
                        player_name: playerName,
                        target_player_name: targetName
                    });
                }
            });
        });
    }

    attachPlayerPingHandlers();

    if (game.status !== 'waiting' && game.status !== 'configuring' && !isSpectator) {
        const player = players.find(p => p.name === playerName);
        if (player && player.role) {
            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');

            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                const displayRole = player.role === 'whiteman' ? 'citizen' : player.role;
                roleDisplay.innerHTML = `Seu papel: <span id="my-role">${getRoleText(displayRole)}</span>`;
                roleDisplay.style.display = 'block';

                if (player.role === 'whiteman') {
                    if (player.word) {
                        wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                    } else {
                        wordDisplay.style.display = 'none';
                    }
                } else if (player.role === 'impostor') {
                    wordDisplay.innerHTML = `<div class="danger-text">‚ö†Ô∏è VOC√ä √â O IMPOSTOR!</div><div>Sua palavra (diferente dos cidad√£os): <span id="my-word" class="danger-text">${player.word || 'N/A'}</span></div>`;
                } else if (player.word) {
                    wordDisplay.innerHTML = `<div>Sua palavra: <span id="my-word">${player.word}</span></div>`;
                } else {
                    wordDisplay.style.display = 'none';
                }

                wordDisplay.style.display = 'block';
            }
        }
    }

    const hintsList = document.getElementById('hints-list');
    hintsList.innerHTML = hints.map(h => {
        return `<div class="hint-item">
            <strong>${h.player_name}</strong> (Rodada ${h.round_number}): ${h.word}
        </div>`;
    }).join('');

    if (hints.length > lastHintCount && game.status === 'hints') {
        playHintSound();
        // Scroll para a √∫ltima dica
        setTimeout(() => {
            hintsList.scrollTop = hintsList.scrollHeight;
        }, 50);
    }
    lastHintCount = hints.length;

    const currentTurnDisplay = document.getElementById('current-turn-display');
    const currentTurnPlayerSpan = document.getElementById('current-turn-player');
    if (game.status === 'hints' && game.current_player) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            currentTurnDisplay.style.display = 'block';
            currentTurnPlayerSpan.textContent = game.current_player;

            if (game.current_player === playerName && game.current_player !== lastCurrentPlayer) {
                playYourTurnSound();
            }
        } else {
            currentTurnDisplay.style.display = 'none';
        }
    } else {
        currentTurnDisplay.style.display = 'none';
    }
    lastCurrentPlayer = game.current_player;

    const hintInputSection = document.getElementById('hint-input-section');
    if (game.status === 'hints' && game.current_player === playerName && !isSpectator) {
        const currentPlayer = players.find(p => p.name === game.current_player && !p.is_eliminated);
        if (currentPlayer) {
            hintInputSection.style.display = 'block';
        }
    } else {
        hintInputSection.style.display = 'none';
    }

    if (isSpectator) {
        document.getElementById('word-display').style.display = 'none';
        document.getElementById('role-display').style.display = 'none';
        document.getElementById('hint-input-section').style.display = 'none';
        document.getElementById('voting-section').style.display = 'none';
    }

    const votingSection = document.getElementById('voting-section');
    if (game.status === 'voting') {
        votingSection.style.display = 'block';
        const activePlayers = players.filter(p => !p.is_eliminated && p.name !== playerName);
        const voteButtons = document.getElementById('vote-buttons');
        voteButtons.innerHTML = activePlayers.map(p => {
            const hasVoted = votes.some(v => v.voter_name === playerName);
            return `<button class="vote-button ${hasVoted ? 'voted' : ''}" 
                    data-target="${p.name}" 
                    ${hasVoted ? 'disabled' : ''}>
                ${p.name}
            </button>`;
        }).join('');

        voteButtons.querySelectorAll('.vote-button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!btn.disabled) {
                    sendMessage({
                        type: 'submit_vote',
                        player_name: playerName,
                        target_name: btn.dataset.target
                    });
                }
            });
        });
    } else {
        votingSection.style.display = 'none';
    }

    const resultsSection = document.getElementById('results-section');
    if (game.status === 'finished') {
        resultsSection.style.display = 'block';

        const impostors = players.filter(p => p.role === 'impostor');
        const activeImpostors = impostors.filter(p => !p.is_eliminated);

        let winnerMessage = '';
        if (activeImpostors.length === 0) {
            winnerMessage = 'üèÜ Cidad√£os ganharam!';
        } else {
            winnerMessage = 'üèÜ Impostores ganharam!';
        }

        document.getElementById('winner-message').innerHTML = `<h2>${winnerMessage}</h2>`;

        const rolesReveal = document.getElementById('roles-reveal');
        rolesReveal.innerHTML = '<h3>Pap√©is revelados:</h3>' + 
            players.map(p => {
                const wordText = p.word ? ` (${p.word})` : '';
                const whitemanAlert = p.role === 'whiteman' && p.is_eliminated ? ' <span class="whiteman-badge">‚ö†Ô∏è Era WhiteMan!</span>' : '';
                return `<div class="player-item">
                    ${p.name}: ${getRoleText(p.role)}${wordText}${whitemanAlert}
                </div>`;
            }).join('');

        const timerDiv = document.getElementById('auto-delete-timer');
        if (timerDiv) {
            timerDiv.style.display = 'block';
        }

        const currentPlayer = players.find(p => p.name === playerName);
        const gameActions = document.getElementById('game-actions');
        if (currentPlayer && currentPlayer.is_creator) {
            gameActions.innerHTML = `
                <button id="restart-btn" class="btn">
                    üîÑ Reiniciar Jogo
                </button>
                <button id="close-room-btn" class="btn btn-danger">
                    üóëÔ∏è Fechar Sala
                </button>
            `;

            const restartBtn = document.getElementById('restart-btn');
            const closeBtn = document.getElementById('close-room-btn');

            if (restartBtn) {
                restartBtn.onclick = () => {
                    if (confirm('Deseja reiniciar o jogo com os mesmos jogadores?')) {
                        sendMessage({
                            type: 'restart_game',
                            player_name: playerName
                        });
                    }
                };
            }

            if (closeBtn) {
                closeBtn.onclick = () => {
                    if (confirm('Tem certeza que deseja fechar a sala? Isso apagar√° todos os dados do jogo!')) {
                        sendMessage({
                            type: 'close_room',
                            player_name: playerName
                        });
                    }
                };
            }
        } else {
            gameActions.innerHTML = '<p>Aguardando o criador da sala reiniciar ou fechar...</p>';
        }
    } else {
        resultsSection.style.display = 'none';
        document.getElementById('winner-message').innerHTML = '';
        document.getElementById('roles-reveal').innerHTML = '';
        const timerDiv = document.getElementById('auto-delete-timer');
        if (timerDiv) {
            timerDiv.style.display = 'none';
        }
    }
}

function getStatusText(status) {
    const statusMap = {
        'waiting': 'Aguardando Jogadores',
        'configuring': 'Configurando',
        'hints': 'Rodada de Dicas',
        'voting': 'Vota√ß√£o',
        'finished': 'Finalizado'
    };
    return statusMap[status] || status;
}

function getRoleText(role) {
    const roleMap = {
        'citizen': 'Cidad√£o',
        'impostor': 'Impostor',
        'whiteman': 'WhiteMan'
    };
    return roleMap[role] || role;
}

if (playerName && !isSpectator) {
    const streamerToggle = document.getElementById('streamer-toggle');
    if (streamerToggle) {
        streamerToggle.addEventListener('click', () => {
            streamerMode = !streamerMode;
            document.body.classList.toggle('streamer-mode', streamerMode);
            streamerToggle.classList.toggle('active', streamerMode);
            streamerToggle.textContent = streamerMode ? 'üîì Modo Normal' : 'üì∫ Modo Streamer';

            const wordDisplay = document.getElementById('word-display');
            const roleDisplay = document.getElementById('role-display');
            if (streamerMode) {
                wordDisplay.style.display = 'none';
                roleDisplay.style.display = 'none';
            } else {
                sendMessage({ type: 'get_state' });
            }
        });
    }
}

if (playerName && !isSpectator) {
    document.getElementById('submit-hint')?.addEventListener('click', () => {
        const word = document.getElementById('hint-word').value.trim();
        if (word) {
            sendMessage({
                type: 'submit_hint',
                player_name: playerName,
                word: word
            });
            document.getElementById('hint-word').value = '';
        }
    });

    document.getElementById('hint-word')?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            document.getElementById('submit-hint').click();
        }
    });
}

if (playerName || isSpectator) {
    connectWebSocket();
}
</script>
{% endblock %}


